//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst2<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
	public class tobepassed{
	int spilltobereported;
	   HashMap<String,Integer> maxargcall;
	   HashMap<String,Integer> maxnumcall;
	   HashMap<String,HashMap<Integer, allocation> > registerallocation;
	   HashMap<String,Integer> spillallocatedforfunc;
	};
	public class liveness implements Comparator<liveness>,Comparable<liveness> {
		int st,end,tempnumber;
		public int compare(liveness d, liveness d1){
		      if(d.st==d1.st) 
		    	  if(d.end<d1.end)
		    		 return -1;
		    	  else if (d.end==d1.end)
		    		  return 0;
		    	  else
		    		  return 1;
		      if(d.st<d1.st)
		    	  		return -1;
		      else
		    	  		return 1;
		   }
		public int compareTo(liveness d1){
			if(st==d1.st) 
		    	  if(end<d1.end)
		    		 return -1;
		    	  else if (end==d1.end)
		    		  return 0;
		    	  else
		    		  return 1;
		      if(st<d1.st)
		    	  		return -1;
		      else
		    	  		return 1;
		}
	};
	public class use_def{
    Set<Integer> s,d;
    };
    public class allocation{
    	int spilled;String register;int flag;
    };
   Integer stmtcount;
   int spilltobereported=0;
   HashMap<String,Integer> maxargcall=new HashMap<String,Integer>();
   int maxargcalltemp;
   HashMap<String,Integer> maxnumcall=new HashMap<String,Integer>();
   int maxnumcalltemp;
   HashMap<String,HashMap<Integer, allocation> > registerallocation=new HashMap<String,HashMap<Integer, allocation> >();
   HashMap<String,Integer> spillallocatedforfunc=new HashMap<String,Integer>();
   HashMap < String,Integer> label;
   HashMap <Integer, Set<Integer> > succ=new HashMap <Integer, Set<Integer> > ();
   HashMap <Integer, Set<Integer> > def=new HashMap <Integer, Set<Integer> > ();
   HashMap <Integer, Set<Integer> > use=new HashMap <Integer, Set<Integer> > ();
   HashMap <String,HashMap<Integer, Set<Integer> > > livein= new HashMap <String,HashMap<Integer, Set<Integer> > >();
   HashMap <String,HashMap<Integer, Set<Integer> > > liveout= new HashMap <String,HashMap<Integer, Set<Integer> > >();
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
       if ( n.present() ) {
         R _ret=null;
         int _count=0;
         LinkedList<R> l = new LinkedList<R>();
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            l.add(e.nextElement().accept(this,argu));
            _count++;
         }
         return (R) l;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() ){
         String lab=(String) n.node.accept(this,argu);
         //label.put(lab,stmtcount+1);
         return (R)lab;
         }
      else
         return null;
   }
   
   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //
   
   int eq(Set<Integer> s1, Set<Integer> s2){
        if(s1.containsAll(s2) && s2.containsAll(s1))
            return 1;
        return 0;
        
        /*int flag=1;
        if(s1.size()!=s2.size())
            return 0;
        Integer [] a1=;s1.toArray(a1);
        a1=Arrays.sort(a1);
        Integer [] a2=Arrays.sort(s2.toArray());
        int len=s1.size();
        for(int i=0;i<len;i++)
            if(a1[i].equals(a2[i])==false )
                return 0;
        return 1;*/
        }
 void spillatinterval(List<liveness> liverange,int i,List<liveness> active,HashMap<Integer, allocation> mappings,List<String> registerpool,Integer spilledallocated){
	 int j;
	 
	 liveness spill=active.get(active.size()-1);
	 if( spill.end>liverange.get(i).end){
		 	allocation temp=new allocation ();
		 	temp.spilled=spilledallocated++;
		 	temp.flag=-1;
		 	mappings.put(liverange.get(i).tempnumber,mappings.get(spill.tempnumber));
		 	mappings.put(spill.tempnumber, temp);
		 	active.remove(spill);
		 	for(j=0;j<active.size();j++){
		    	 if(active.get(j).end>liverange.get(i).end)
		    		 break;
					 
		     }
			 active.add(j,liverange.get(i));
		 	
		 	
	 }
	 else{
		 allocation temp=new allocation ();
		 	temp.spilled=spilledallocated++;
		 	temp.flag=-1;
		 	mappings.put(liverange.get(i).tempnumber,temp);
		 	
	 }
 }
 void expireoldintervals(List<liveness> liverange,int i,List<liveness> active,HashMap<Integer, allocation> mappings,List<String> registerpool){
	 int j;
	 for(j=0;j<active.size();j++){
		 if(active.get(j).end>=liverange.get(i).st )
			 return;
		 registerpool.add(mappings.get(active.get(j).tempnumber).register);
		 active.remove(j);
		 j--;
	 }
 }
 int linear_scan(List<liveness> liverange,int size, int sallocated,int tallocated,int spilledallocated, HashMap<Integer, allocation> mappings){
	 Integer numspilled=0;
	 List<String> registerpool=new ArrayList<String> ();
	 int i,j;int Rnum=10+8-sallocated;
	 for(i=sallocated;i<8;i++)
		 registerpool.add("s"+i);
	 for(i=0;i<10;i++)
		 registerpool.add("t"+i);
	 List<liveness> active=new ArrayList<liveness> ();
	 for(i=0;i<size;i++){
		 expireoldintervals(liverange,i,active,mappings,registerpool);
		 if(active.size()== Rnum ){
			 numspilled++;
			 spillatinterval(liverange,i,active,mappings,registerpool,spilledallocated);
		 }
		 else{
			 allocation temp=new allocation();
			 temp.register=registerpool.get(0);
			 registerpool.remove(0);
			 temp.flag=1;
			 mappings.put(liverange.get(i).tempnumber, temp);
			 
		     for(j=0;j<active.size();j++){
		    	 if(active.get(j).end>liverange.get(i).end)
		    		 break;
					 
		     }
			 active.add(j,liverange.get(i));
			 
		 }
			 	
		 
	 }
	 
return numspilled;	 
 }

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
	  maxargcalltemp=0;
	  maxnumcalltemp=0;
      stmtcount=0;
      label=(HashMap < String,Integer>) argu;
      HashMap<Integer, allocation> mappings=new HashMap<Integer,allocation> ();
      Integer stmtstart=1;
      String funcName="MAIN";
      Integer param=0;
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      maxargcall.put(funcName,maxargcalltemp);
      maxnumcall.put(funcName, maxnumcalltemp);
   
      Integer stmtend=stmtcount;
      Set<Integer> c= succ.get(stmtcount);
      c.remove(stmtcount+1);
      c.add(-1);
      HashMap<Integer, Set<Integer> > hin=new HashMap<Integer, Set<Integer> >();
      HashMap<Integer, Set<Integer> > hout=new HashMap<Integer, Set<Integer> >();
        Integer no;
        for(no=stmtstart;no<=stmtend;no++){
            Set<Integer> s1=new HashSet<Integer>();
            Set<Integer> s2=new HashSet<Integer>();
            hin.put(no,s1);
            hout.put(no,s2);
        }
        int flag=1;
        int ctin=1,cthout=0;
        while(ctin!=0 || cthout!=0 ){
        	ctin=0;cthout=0;
            //HashMap<Integer, Set<Integer> > hindash=new HashMap<Integer, Set<Integer> >();
            //HashMap<Integer, Set<Integer> > houtdash=new HashMap<Integer, Set<Integer> >();
            for(Integer nu=stmtstart;nu<=stmtend;nu++){
                //hindash.put(nu,new HashSet<Integer>(hin.get(nu)));
                //houtdash.put(nu,new HashSet<Integer>(hout.get(nu)));
                //hin.get(nu).addAll(use.get(nu));
                cthout+=hout.get(nu).size();
                ctin+=hin.get(nu).size();
            	Set<Integer> temp=new HashSet<Integer> (hout.get(nu));
                temp.removeAll(def.get(nu));
                temp.addAll(use.get(nu));
                hin.put(nu,temp);
                Set<Integer> temp2=new HashSet<Integer> ();
                for(Integer i : succ.get(nu))
                    if(i!=-1)
                        temp2.addAll(hin.get(i));
                hout.put(nu,temp2);
                ctin-=hin.get(nu).size();
                cthout-=hout.get(nu).size();
              }
              
                        
           /*int flag2=0;
           for(Integer nu=stmtstart;nu<=stmtend;nu++){
            if(eq(hout.get(nu),houtdash.get(nu))==0)
                flag2=1;
            if(eq(hin.get(nu),hindash.get(nu))==0)
                flag2=1;
           }
            
           if(flag2==0)
            flag=0;*/
            }
      livein.put(funcName,hin);
      liveout.put(funcName,hout); 
      
      HashMap<Integer,Integer> liverangestart=new HashMap<Integer,Integer>();
      HashMap<Integer,Integer> liverangeend=new HashMap<Integer,Integer>();
      for(int i=stmtstart;i<=stmtend;i++){
    	  
    	  Set<Integer> st1=def.get(i);
    	  for(Integer j : st1){
  	  		if(!liverangestart.containsKey(j)){
  	  			liverangestart.put(j,i);
  	  			liverangeend.put(j,i);
  	  		}
  	  		else
  	  			if(liverangeend.get(j)<i){
  	  				liverangeend.put(j, i);
  	  		}
    	  
    	  	for(Integer k : hin.get(i)){
    	  			if(!liverangeend.containsKey(k)){
    	  					liverangeend.put(k,i);
    	  			}
    	  			else
    	  				if(liverangeend.get(k)<i)
    	  					liverangeend.put(k,i);
    	  	
    	  	}
    	  } 	
    
      }
    int sallocated=0,tallocated=0, spilledallocated=0;
    for(int i=0;i<param;i++){
    	if(i<3){
    		allocation temp=new allocation();
    		temp.register="s"+sallocated;
    		temp.flag=1;
    		mappings.put(i, temp);
    		sallocated++;
    	}
    	else{
    		allocation temp2=new allocation();
    		temp2.spilled= spilledallocated++;
    		temp2.flag=-1;
    		mappings.put(i,temp2);
    		
    	}
    	liverangestart.remove(i);liverangeend.remove(i);
       
    }
    Set<Integer> alltempnumbers=liverangestart.keySet();
    List<liveness> liverange=new ArrayList<liveness>();
    int m=0;
    for(Integer l : alltempnumbers){
    	liveness b=new liveness();
    	b.st=liverangestart.get(l);
    	b.end=liverangeend.get(l);
    	b.tempnumber=l;
    	liverange.add(b);
    	
    	
    }
    
    int siz=alltempnumbers.size();
    Collections.sort(liverange);
    //liveness [] liverange2=null;
    //liverange2=liverange.toArray(new liveness[0]);
    spilltobereported+= linear_scan(liverange,siz,sallocated,tallocated,spilledallocated,mappings);  
    registerallocation.put(funcName, mappings);
    spillallocatedforfunc.put(funcName, spilledallocated);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      
      tobepassed pass=new tobepassed();
      pass.spilltobereported=spilltobereported;
      pass.maxargcall=maxargcall;
      pass.maxnumcall=maxnumcall;
      pass.registerallocation=registerallocation;
      pass.spillallocatedforfunc=spillallocatedforfunc;
      
    /*  for(Integer klm:mappings.keySet()){
    	  allocation b=mappings.get(klm);
    	  if(b.flag==1)
    		  System.out.println(klm+" "+b.register+" ");
    	  else
    		  System.out.println(b.spilled+" ");
    	  System.out.println(liverangestart.get(klm)+" "+liverangeend.get(klm));
      }*/
      return (R)pass;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      maxargcalltemp=0;
      maxnumcalltemp=0;
      HashMap<Integer, allocation> mappings=new HashMap<Integer,allocation> ();
      Integer stmtstart=++stmtcount;
      Set<Integer> tt=new HashSet<Integer> ();
      tt.add(stmtcount+1);
      succ.put(stmtcount,tt);
      Set<Integer> s=new HashSet<Integer>();
      Set<Integer> d=new HashSet<Integer>();
      use.put(stmtcount,s);
      def.put(stmtcount,d);
      String funcName=(String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      Integer param=Integer.parseInt((String)n.f2.accept(this, argu));
      for(Integer i=0;i<param;i++)
        d.add(new Integer(i));
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      maxargcall.put(funcName,maxargcalltemp);
      maxnumcall.put(funcName, maxnumcalltemp);
      Integer stmtend=stmtcount;
      HashMap<Integer, Set<Integer> > hin=new HashMap<Integer, Set<Integer> >();
      HashMap<Integer, Set<Integer> > hout=new HashMap<Integer, Set<Integer> >();
        Integer no;
        for(no=stmtstart;no<=stmtend;no++){
            Set<Integer> s1=new HashSet<Integer>();
            Set<Integer> s2=new HashSet<Integer>();
            hin.put(no,s1);
            hout.put(no,s2);
        }
        int flag=1;
        int ctin=1,cthout=0;
        while(ctin!=0 || cthout!=0 ){
        	ctin=0;cthout=0;
            //HashMap<Integer, Set<Integer> > hindash=new HashMap<Integer, Set<Integer> >();
            //HashMap<Integer, Set<Integer> > houtdash=new HashMap<Integer, Set<Integer> >();
            for(Integer nu=stmtstart;nu<=stmtend;nu++){
                //hindash.put(nu,new HashSet<Integer>(hin.get(nu)));
                //houtdash.put(nu,new HashSet<Integer>(hout.get(nu)));
                //hin.get(nu).addAll(use.get(nu));
                cthout+=hout.get(nu).size();
                ctin+=hin.get(nu).size();
            	Set<Integer> temp=new HashSet<Integer> (hout.get(nu));
                temp.removeAll(def.get(nu));
                temp.addAll(use.get(nu));
                hin.put(nu,temp);
                Set<Integer> temp2=new HashSet<Integer> ();
                for(Integer i : succ.get(nu))
                    if(i!=-1)
                        temp2.addAll(hin.get(i));
                hout.put(nu,temp2);
                ctin-=hin.get(nu).size();
                cthout-=hout.get(nu).size();
              }
              
                        
           /*int flag2=0;
           for(Integer nu=stmtstart;nu<=stmtend;nu++){
            if(eq(hout.get(nu),houtdash.get(nu))==0)
                flag2=1;
            if(eq(hin.get(nu),hindash.get(nu))==0)
                flag2=1;
           }
            
           if(flag2==0)
            flag=0;*/
            }
      livein.put(funcName,hin);
      liveout.put(funcName,hout); 
      
      HashMap<Integer,Integer> liverangestart=new HashMap<Integer,Integer>();
      HashMap<Integer,Integer> liverangeend=new HashMap<Integer,Integer>();
      for(int i=stmtstart;i<=stmtend;i++){
    	  
    	  Set<Integer> st1=def.get(i);
    	  for(Integer j : st1){
  	  		if(!liverangestart.containsKey(j)){
  	  			liverangestart.put(j,i);
  	  			liverangeend.put(j,i);
  	  		}
  	  		else
  	  			if(liverangeend.get(j)<i){
  	  				liverangeend.put(j, i);
  	  		}
    	  
    	  	for(Integer k : hin.get(i)){
    	  			if(!liverangeend.containsKey(k)){
    	  					liverangeend.put(k,i);
    	  			}
    	  			else
    	  				if(liverangeend.get(k)<i)
    	  					liverangeend.put(k,i);
    	  	
    	  	}
    	  } 	
    
      }
      
      //System.out.println("LIVE RANGE OF 104 "+liverangestart.get(104)+" "+liverangeend.get(104));
    int sallocated=0,tallocated=0, spilledallocated=0;
    for(int i=0;i<param;i++){
    	if(i<=3){
    		allocation temp=new allocation();
    		temp.register="s"+sallocated;
    		temp.flag=1;
    		mappings.put(i, temp);
    		sallocated++;
    	}
    	else{
    		allocation temp2=new allocation();
    		temp2.spilled= spilledallocated++;
    		temp2.flag=-1;
    		mappings.put(i,temp2);
    		
    	}
    	liverangestart.remove(i);liverangeend.remove(i);
       
    }
    spilledallocated+=18;
    Set<Integer> alltempnumbers=liverangestart.keySet();
    List<liveness> liverange=new ArrayList<liveness>();
    int m=0;
    for(Integer l : alltempnumbers){
    	liveness b=new liveness();
    	b.st=liverangestart.get(l);
    	b.end=liverangeend.get(l);
    	b.tempnumber=l;
    	liverange.add(b);
    	
    	
    }
    
    int size=alltempnumbers.size();
    Collections.sort(liverange);
    //liveness [] liverange2=null;
    //liverange.toArray(liverange2);
    spilltobereported+= linear_scan(liverange,size,sallocated,tallocated,spilledallocated,mappings);  
    registerallocation.put(funcName, mappings);
    spillallocatedforfunc.put(funcName, spilledallocated);
    //System.out.print(funcName+"\n");
    Integer v;
    //System.out.println(liverangestart.get(104)+" "+liverangeend.get(104));
    /*for(v=stmtstart;v<=stmtend;v++){
    	System.out.println(v+" use");
    	for(  Integer l : use.get(v))
    		System.out.println(l+" ");
    	System.out.println("\n def");
    	for( Integer h : def.get(v))
    		System.out.println(h+" ");
    }*/
    
    /*for(v=stmtstart;v<=stmtend;v++){
    	System.out.println("\n\n"+v+" ");
    	System.out.println(" succ");
    	for(  Integer lk : succ.get(v))
    		System.out.println(lk+" ");
    	System.out.println(" use");
    	for(  Integer l : use.get(v))
    		System.out.println(l+" ");
    	System.out.println("def");
    	for( Integer h : def.get(v))
    		System.out.println(h+" ");
	System.out.println(" livein");
	for(  Integer l : hin.get(v))
		System.out.println(l+" ");
	System.out.println("liveout");
	for( Integer h : hout.get(v))
		System.out.println(h+" ");
	
	}*/
    //System.out.println("jump "+label.get("L26"));
    /*for(Integer klm:mappings.keySet()){
  	  allocation b=mappings.get(klm);
  	  if(b.flag==1)
  		  System.out.println(klm+" "+b.register+" ");
  	  else
  		  System.out.println(klm+" "+b.spilled+" ");
  	  System.out.println(liverangestart.get(klm)+" "+liverangeend.get(klm));
    }*/
    /*if(funcName=="List_Print")
    System.out.println(liverangestart.get(104)+" "+liverangeend.get(104));
    System.out.println(liverangestart.get(104)+" "+liverangeend.get(104));
    System.out.println(liverangestart.get(104)+" "+liverangeend.get(104));*/
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      stmtcount++;
      Set<Integer> s=new HashSet<Integer>();
      Set<Integer> d=new HashSet<Integer>();
      use.put(stmtcount,s);
      def.put(stmtcount,d);
      use_def b= new use_def();b.s=s;b.d=d;
      argu=(A)b;
      n.f0.accept(this, argu);
      
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      Set<Integer> temp=new HashSet<Integer> ();
      temp.add(stmtcount+1);
      succ.put(stmtcount,temp);
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      Set<Integer> temp=new HashSet<Integer> ();
      temp.add(stmtcount+1);
      succ.put(stmtcount,temp);
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      use_def b=(use_def) argu;
      n.f0.accept(this, argu);
      String t=(String)n.f1.accept(this, argu);
      String lab=(String)n.f2.accept(this, argu);
      Set<Integer> temp=new HashSet<Integer> ();
      temp.add(label.get(lab));
      temp.add(stmtcount+1);
      succ.put(stmtcount,temp);
      b.s.add(Integer.parseInt(t));
      
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
       
      n.f0.accept(this, argu);
      String lab=(String)n.f1.accept(this, argu);
      Set<Integer> temp=new HashSet<Integer> ();
      temp.add(label.get(lab));
      succ.put(stmtcount,temp);
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      use_def b=(use_def) argu;
      R _ret=null;
       Set<Integer> temp=new HashSet<Integer> ();
      temp.add(stmtcount+1);
      succ.put(stmtcount,temp);
      n.f0.accept(this, argu);
      String s1=(String)n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      String s2=(String)n.f3.accept(this, argu);
      b.s.add(Integer.parseInt(s2));
      b.s.add(Integer.parseInt(s1));
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      use_def b=(use_def) argu;
      R _ret=null;
       Set<Integer> temp=new HashSet<Integer> ();
      temp.add(stmtcount+1);
      succ.put(stmtcount,temp);
      n.f0.accept(this, argu);
      String s1=(String)n.f1.accept(this, argu);
      String s2=(String)n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      b.s.add(Integer.parseInt(s2));
      b.d.add(Integer.parseInt(s1));
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      use_def b=(use_def) argu;
      R _ret=null;
       Set<Integer> temp=new HashSet<Integer> ();
      temp.add(stmtcount+1);
      succ.put(stmtcount,temp);
      n.f0.accept(this, argu);
      String s1=(String)n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      b.d.add(Integer.parseInt(s1));
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      Set<Integer> temp=new HashSet<Integer> ();
      temp.add(stmtcount+1);
      succ.put(stmtcount,temp);
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      stmtcount++;
      Set<Integer> s1=new HashSet<Integer> ();
      s1.add(-1);
      succ.put(stmtcount,s1);
      Set<Integer> s=new HashSet<Integer>();
      Set<Integer> d=new HashSet<Integer>();
      use.put(stmtcount,s);
      def.put(stmtcount,d);
      use_def b= new use_def();b.s=s;b.d=d;
      argu=(A)b;
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      use_def b=(use_def) argu;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      R temp=n.f3.accept(this, argu);
      maxnumcalltemp++;
      if(temp!=null){
    	
        LinkedList<R> l=(LinkedList<R>) temp;
        if(l.size()>maxargcalltemp)
        	maxargcalltemp=l.size();
        		
        Iterator<R> iter=l.iterator();
        while(iter.hasNext())
            b.s.add(Integer.parseInt((String)iter.next()));
        }
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      use_def b=(use_def) argu;
      n.f0.accept(this, argu);
      String s1=(String)n.f1.accept(this, argu);
      b.s.add(Integer.parseInt(s1));
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "LT"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      R temp=n.f0.accept(this, argu);
      if(n.f0.which==0){
        use_def b=(use_def) argu;
        b.s.add(Integer.parseInt((String)temp));
        return temp;
        } 
      if(n.f0.which==2)
        return temp;
        
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String inte=(String)n.f1.accept(this, argu);
      return (R)inte;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      
      return (R)n.f0.toString() ;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return (R) n.f0.toString();
   }

}
